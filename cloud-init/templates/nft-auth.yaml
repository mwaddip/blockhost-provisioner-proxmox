#cloud-config
# NFT Authentication Cloud-Init Template
# Variables (substituted by vm-generator.py):
#   ${VM_NAME}         - VM hostname
#   ${VM_IP}           - Allocated IPv4 address (private)
#   ${VM_IPV6}         - Allocated IPv6 address (public, may be empty)
#   ${SIGNING_HOST}    - Host for signing URL ([ipv6] or ipv4)
#   ${USERNAME}        - Linux username
#   ${NFT_TOKEN_ID}    - Reserved NFT token ID
#   ${CHAIN_ID}        - Blockchain chain ID
#   ${NFT_CONTRACT}    - NFT contract address
#   ${RPC_URL}         - JSON-RPC endpoint URL
#   ${OTP_LENGTH}      - OTP code length
#   ${OTP_TTL}         - OTP time-to-live in seconds
#   ${SECRET_KEY}      - Random 64-char hex string for PAM module

hostname: ${VM_NAME}

packages:
  - qemu-guest-agent
  - certbot

users:
  - name: ${USERNAME}
    gecos: "nft=${NFT_TOKEN_ID}"
    groups: sudo
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    ssh_authorized_keys: ${SSH_KEYS}

write_files:
  - path: /etc/pam_web3/config.toml
    permissions: '0640'
    content: |
      [machine]
      id = "${VM_NAME}"
      secret_key = "${SECRET_KEY}"

      [auth]
      mode = "nft"
      nft_lookup = "passwd"
      signing_url = "http://${SIGNING_HOST}:8080"
      otp_length = ${OTP_LENGTH}
      otp_ttl_seconds = ${OTP_TTL}

      [blockchain]
      socket_path = "/run/web3-auth/web3-auth.sock"
      chain_id = ${CHAIN_ID}
      nft_contract = "${NFT_CONTRACT}"
      timeout_seconds = 10

  - path: /etc/web3-auth/config.toml
    permissions: '0640'
    content: |
      socket_path = "/run/web3-auth/web3-auth.sock"
      backend = "jsonrpc"
      default_chain_id = ${CHAIN_ID}
      default_contract = "${NFT_CONTRACT}"

      [jsonrpc]
      rpc_url = "${RPC_URL}"
      timeout_seconds = 30

  - path: /etc/pam.d/sshd
    content: |
      # Web3 NFT authentication for all users
      auth [success=done default=die] pam_web3.so

      # Standard account/session management
      account    required     pam_nologin.so
      @include common-account
      session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
      session    required     pam_loginuid.so
      session    optional     pam_keyinit.so force revoke
      @include common-session
      session    optional     pam_motd.so  motd=/run/motd.dynamic
      session    optional     pam_motd.so noupdate
      session    optional     pam_mail.so standard noenv
      session    required     pam_limits.so
      session    required     pam_env.so
      session    required     pam_env.so user_readenv=1 envfile=/etc/default/locale
      session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so open
      @include common-password

  - path: /etc/ssh/sshd_config.d/web3-only.conf
    content: |
      # Web3 authentication only - disable all other methods
      PubkeyAuthentication no
      PasswordAuthentication no
      KbdInteractiveAuthentication yes
      UsePAM yes
      AuthenticationMethods keyboard-interactive

  - path: /usr/local/bin/wait-for-nft.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Wait for NFT to be minted before starting the signing page
      # The NFT is minted AFTER terraform apply succeeds, so there's a race condition

      CONTRACT="${NFT_CONTRACT}"
      RPC_URL="${RPC_URL}"
      TOKEN_ID="${NFT_TOKEN_ID}"
      TIMEOUT=300  # 5 minutes
      INTERVAL=5   # Check every 5 seconds

      echo "Waiting for NFT #$TOKEN_ID to be minted on contract $CONTRACT..."

      # Convert token ID to hex (padded to 32 bytes)
      TOKEN_HEX=$(printf '%064x' "$TOKEN_ID")

      # ownerOf(uint256) function selector: 0x6352211e
      CALL_DATA="0x6352211e$TOKEN_HEX"

      check_nft_exists() {
          # Use cast if available (faster, cleaner output)
          if command -v cast &>/dev/null; then
              cast call "$CONTRACT" "ownerOf(uint256)(address)" "$TOKEN_ID" --rpc-url "$RPC_URL" 2>/dev/null
              return $?
          fi

          # Fallback to curl with JSON-RPC
          response=$(curl -s -X POST "$RPC_URL" \
              -H "Content-Type: application/json" \
              -d "{\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[{\"to\":\"$CONTRACT\",\"data\":\"$CALL_DATA\"},\"latest\"],\"id\":1}")

          # Check if response contains an error (token doesn't exist = revert)
          if echo "$response" | grep -q '"error"'; then
              return 1
          fi

          # Check if result is a valid address (not 0x or empty)
          result=$(echo "$response" | grep -o '"result":"[^"]*"' | cut -d'"' -f4)
          if [ -z "$result" ] || [ "$result" = "0x" ]; then
              return 1
          fi

          return 0
      }

      start_time=$(date +%s)
      while true; do
          if check_nft_exists; then
              echo "NFT #$TOKEN_ID found!"
              exit 0
          fi

          # Check timeout
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          if [ $elapsed -ge $TIMEOUT ]; then
              echo "Timeout waiting for NFT #$TOKEN_ID after ${TIMEOUT}s"
              exit 1
          fi

          echo "NFT not found yet, retrying in ${INTERVAL}s... (${elapsed}s elapsed)"
          sleep $INTERVAL
      done

  - path: /usr/local/bin/serve-signing-page.py
    permissions: '0755'
    content: |
      #!/usr/bin/env python3
      """
      Fetch NFT signing page from on-chain metadata and serve it via HTTP.

      This script:
      1. Calls tokenURI(tokenId) on the NFT contract via JSON-RPC
      2. Decodes the base64 JSON metadata
      3. Extracts animation_url (base64 HTML)
      4. Serves the HTML on the specified port
      """

      import argparse
      import base64
      import http.server
      import json
      import socketserver
      import sys
      import urllib.request


      def eth_call(rpc_url: str, contract: str, data: str) -> str:
          """Make an eth_call to the contract."""
          payload = {
              "jsonrpc": "2.0",
              "method": "eth_call",
              "params": [{"to": contract, "data": data}, "latest"],
              "id": 1
          }
          req = urllib.request.Request(
              rpc_url,
              data=json.dumps(payload).encode(),
              headers={"Content-Type": "application/json", "User-Agent": "BlockhostVM/1.0"}
          )
          with urllib.request.urlopen(req, timeout=30) as resp:
              result = json.loads(resp.read().decode())

          if "error" in result:
              raise RuntimeError(f"RPC error: {result['error']}")

          return result["result"]


      def decode_string_from_abi(hex_data: str) -> str:
          """Decode a string from ABI-encoded hex data."""
          # Remove 0x prefix
          data = hex_data[2:] if hex_data.startswith("0x") else hex_data

          # ABI encoding: first 32 bytes = offset, next 32 bytes = length, then data
          # For a simple string return, offset points to where length starts
          offset = int(data[0:64], 16) * 2  # offset in hex chars
          length = int(data[offset:offset+64], 16)
          string_data = data[offset+64:offset+64+length*2]

          return bytes.fromhex(string_data).decode('utf-8')


      def get_signing_page(rpc_url: str, contract: str, token_id: int) -> str:
          """Fetch the signing page HTML from the NFT's tokenURI."""
          # tokenURI(uint256) selector: 0xc87b56dd
          token_hex = format(token_id, '064x')
          call_data = f"0xc87b56dd{token_hex}"

          print(f"Fetching tokenURI for token #{token_id}...")
          result = eth_call(rpc_url, contract, call_data)
          token_uri = decode_string_from_abi(result)

          # tokenURI is a data URI: data:application/json;base64,<base64_json>
          if not token_uri.startswith("data:application/json;base64,"):
              raise ValueError(f"Unexpected tokenURI format: {token_uri[:50]}...")

          # Decode the JSON metadata
          json_b64 = token_uri.split(",", 1)[1]
          metadata = json.loads(base64.b64decode(json_b64).decode())

          # Extract animation_url (the signing page HTML as base64)
          animation_url = metadata.get("animation_url", "")
          if not animation_url:
              raise ValueError("No animation_url in NFT metadata")

          # animation_url is: data:text/html;base64,<base64_html>
          if animation_url.startswith("data:text/html;base64,"):
              html_b64 = animation_url.split(",", 1)[1]
          else:
              # Might be just base64 without the data URI prefix
              html_b64 = animation_url

          html_content = base64.b64decode(html_b64).decode()
          print(f"Retrieved signing page: {len(html_content)} bytes")

          return html_content


      class SigningPageHandler(http.server.BaseHTTPRequestHandler):
          """HTTP handler that serves the signing page."""

          html_content = ""

          def do_GET(self):
              self.send_response(200)
              self.send_header("Content-Type", "text/html; charset=utf-8")
              self.send_header("Content-Length", len(self.html_content.encode()))
              self.send_header("Cache-Control", "no-cache")
              self.end_headers()
              self.wfile.write(self.html_content.encode())

          def log_message(self, format, *args):
              print(f"[HTTP] {args[0]}")


      def main():
          parser = argparse.ArgumentParser(description="Serve NFT signing page")
          parser.add_argument("--contract", required=True, help="NFT contract address")
          parser.add_argument("--rpc-url", required=True, help="JSON-RPC endpoint URL")
          parser.add_argument("--token-id", required=True, type=int, help="NFT token ID")
          parser.add_argument("--port", type=int, default=8080, help="HTTP port (default: 8080)")

          args = parser.parse_args()

          try:
              html_content = get_signing_page(args.rpc_url, args.contract, args.token_id)
          except Exception as e:
              print(f"Error fetching signing page: {e}", file=sys.stderr)
              sys.exit(1)

          SigningPageHandler.html_content = html_content

          with socketserver.TCPServer(("", args.port), SigningPageHandler) as httpd:
              print(f"Serving signing page on http://0.0.0.0:{args.port}")
              httpd.serve_forever()


      if __name__ == "__main__":
          main()

  - path: /etc/systemd/system/web3-sign.service
    content: |
      [Unit]
      Description=Web3 Signing Page HTTP Server
      After=network.target

      [Service]
      Type=simple
      ExecStartPre=/usr/local/bin/wait-for-nft.sh
      ExecStart=/usr/bin/python3 /usr/local/bin/serve-signing-page.py --contract ${NFT_CONTRACT} --rpc-url ${RPC_URL} --token-id ${NFT_TOKEN_ID} --port 8080
      Restart=on-failure
      RestartSec=30

      [Install]
      WantedBy=multi-user.target

runcmd:
  # Enable qemu-guest-agent for Proxmox/Terraform
  - systemctl enable --now qemu-guest-agent

  # Start services
  - systemctl daemon-reload
  - systemctl enable --now web3-auth-svc
  - systemctl enable --now web3-sign
  - systemctl restart sshd

  # Setup HTTPS with sslip.io (runs async to not block boot)
  - |
    cat > /usr/local/bin/setup-https.sh << 'SCRIPT'
    #!/bin/bash
    # Auto-setup HTTPS with Let's Encrypt using sslip.io
    set -e

    VM_NAME="${VM_NAME}"
    VM_IPV6="${VM_IPV6}"

    # Skip if no IPv6 configured
    if [ -z "$VM_IPV6" ]; then
        echo "No IPv6 configured, skipping HTTPS setup"
        exit 0
    fi

    # Convert IPv6 to dashed format for sslip.io
    # e.g., 2a11:6c7:f04:276::2 -> 2a11-6c7-f04-276--2.sslip.io
    IPV6_DASHED=$(echo "$VM_IPV6" | sed 's/:/-/g')
    DOMAIN="${VM_NAME}.${IPV6_DASHED}.sslip.io"

    echo "Setting up HTTPS for $DOMAIN..."

    # Stop signing page temporarily for certbot
    systemctl stop web3-sign || true

    # Get certificate (standalone mode on port 8080)
    certbot certonly --standalone --non-interactive --agree-tos \
        --register-unsafely-without-email \
        --domains "$DOMAIN" \
        --http-01-port 8080 || {
        echo "Certbot failed, continuing with HTTP"
        systemctl start web3-sign
        exit 0
    }

    # Update pam_web3 config with HTTPS URL
    sed -i "s|signing_url = \"http://.*\"|signing_url = \"https://${DOMAIN}\"|" /etc/pam_web3/config.toml

    # Create HTTPS server wrapper
    cat > /usr/local/bin/serve-signing-page-https.py << 'HTTPS_SCRIPT'
    #!/usr/bin/env python3
    """HTTPS wrapper for signing page server."""
    import http.server
    import ssl
    import sys
    import os

    # Import the original server
    sys.path.insert(0, '/usr/local/bin')
    from importlib.machinery import SourceFileLoader
    original = SourceFileLoader('serve_signing_page', '/usr/local/bin/serve-signing-page.py').load_module()

    def main():
        import argparse
        parser = argparse.ArgumentParser(description="Serve NFT signing page over HTTPS")
        parser.add_argument("--contract", required=True)
        parser.add_argument("--rpc-url", required=True)
        parser.add_argument("--token-id", required=True, type=int)
        parser.add_argument("--port", type=int, default=443)
        parser.add_argument("--cert", required=True)
        parser.add_argument("--key", required=True)
        args = parser.parse_args()

        html_content = original.get_signing_page(args.rpc_url, args.contract, args.token_id)
        original.SigningPageHandler.html_content = html_content

        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        context.load_cert_chain(args.cert, args.key)

        import socketserver
        with socketserver.TCPServer(("", args.port), original.SigningPageHandler) as httpd:
            httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
            print(f"Serving signing page on https://0.0.0.0:{args.port}")
            httpd.serve_forever()

    if __name__ == "__main__":
        main()
    HTTPS_SCRIPT
    chmod +x /usr/local/bin/serve-signing-page-https.py

    # Update systemd service for HTTPS
    CERT_PATH="/etc/letsencrypt/live/${DOMAIN}"
    cat > /etc/systemd/system/web3-sign.service << EOF
    [Unit]
    Description=Web3 Signing Page HTTPS Server
    After=network.target

    [Service]
    Type=simple
    ExecStartPre=/usr/local/bin/wait-for-nft.sh
    ExecStart=/usr/bin/python3 /usr/local/bin/serve-signing-page-https.py --contract ${NFT_CONTRACT} --rpc-url ${RPC_URL} --token-id ${NFT_TOKEN_ID} --port 443 --cert ${CERT_PATH}/fullchain.pem --key ${CERT_PATH}/privkey.pem
    Restart=on-failure
    RestartSec=30
    AmbientCapabilities=CAP_NET_BIND_SERVICE

    [Install]
    WantedBy=multi-user.target
    EOF

    systemctl daemon-reload
    systemctl start web3-sign

    echo "HTTPS configured at https://${DOMAIN}"
    SCRIPT
    chmod +x /usr/local/bin/setup-https.sh

  # Run HTTPS setup in background (don't block boot)
  - nohup /usr/local/bin/setup-https.sh > /var/log/setup-https.log 2>&1 &

final_message: "Web3 NFT authentication configured after $UPTIME seconds"
